<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Webpack 多级路由与 Echarts 折线非节点选中</title>
    <link href="/20211214-summary/"/>
    <url>/20211214-summary/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/77329102_p10.jpg" srcset="/img/loading.gif" alt="77329102_p10"></p><p>总结一下最近遇到的两个小问题</p><h2 id="Webpack-多级路由导致二级路由刷新-404-的问题"><a href="#Webpack-多级路由导致二级路由刷新-404-的问题" class="headerlink" title="Webpack 多级路由导致二级路由刷新 404 的问题"></a>Webpack 多级路由导致二级路由刷新 404 的问题</h2><p>React 配置多级路由之后, Webpack 如果没有特意配置的话, 可能会出现二级路由页面刷新报 404 的问题, 咕咕搜出来的解决方法一般是在 Webpack 的 output 里面增加配置项 <code>output: { publicPath: &#39;/&#39; }</code></p><p>这样可以解决二级路由刷新 404, 但是又会导致打包之后图片等静态文件引入路径不对的问题</p><h3 id="完整解决方法"><a href="#完整解决方法" class="headerlink" title="完整解决方法"></a>完整解决方法</h3><ol><li>Webpack 添加配置项 <code>output: { publicPath: &#39;/&#39; }</code></li><li>Webpack file-loader 添加 options, 配置静态文件输出路径 <code>options: { outputPath: &#39;images/&#39; }</code></li><li>Webpack url-loader 添加 options, 配置静态文件输出路径 <code>options: { outputPath: &#39;images/&#39; }</code></li></ol><h2 id="Echarts-折线非节点选中问题"><a href="#Echarts-折线非节点选中问题" class="headerlink" title="Echarts 折线非节点选中问题"></a>Echarts 折线非节点选中问题</h2><p>Echarts 自带的事件监听里面, 鼠标 click 对于折线只有数据点能触发, 折线上的其他部分是无法触发的, 咕咕搜出来全是抄来抄去的重复答案, 而且根本解决不了问题</p><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><ol><li>利用 getZr 函数绑定图表事件</li><li><strong>重点</strong> 设置 series 的 z 属性, 用于判断当前触发的是哪个 series</li><li>执行业务操作</li></ol><blockquote><p>直接贴个代码</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">// 注意 series 配置, 添加 z 属性 (或者用其他非官方属性来作为索引, 没试过, 应该也可以)</span><span class="hljs-comment">/*</span><span class="hljs-comment">  options &#123;</span><span class="hljs-comment">    ...</span><span class="hljs-comment">    series: &#123;</span><span class="hljs-comment">      ...</span><span class="hljs-comment">      z: [index],</span><span class="hljs-comment">    &#125;</span><span class="hljs-comment">  &#125;</span><span class="hljs-comment">*/</span><span class="hljs-comment">// echarts 实例, echarts-for-react 用 ref 获取, 普通 echarts 直接 init 获取</span><span class="hljs-keyword">const</span> echartsInstance = echartsRef.current.getEchartsInstance();echartsInstance.getZr().on(<span class="hljs-string">"click"</span>, click);<span class="hljs-comment">// 必须用 getZr 来绑定事件, 不然没办法触发折线事件</span><span class="hljs-comment">// 可以绑定 mousemove, click 等</span><span class="hljs-comment">/**</span><span class="hljs-comment"> * 事件回调</span><span class="hljs-comment"> */</span><span class="hljs-keyword">const</span> click = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;  <span class="hljs-keyword">const</span> echartsInstance = echartsRef.current.getEchartsInstance();  <span class="hljs-comment">// 获取当前点击的位置</span>  <span class="hljs-keyword">const</span> &#123; target, offsetX, offsetY &#125; = e;  <span class="hljs-keyword">const</span> pointInPixel = [offsetX, offsetY];  <span class="hljs-comment">// 判断点击是否位于图表内</span>  <span class="hljs-keyword">if</span> (echartsInstance.containPixel(<span class="hljs-string">"grid"</span>, pointInPixel)) &#123;    <span class="hljs-comment">// 获取点击的 seriesIndex</span>    <span class="hljs-keyword">if</span> (target) &#123;      <span class="hljs-keyword">const</span> index = target.z;      <span class="hljs-comment">// 利用 series 的 z 属性获取当前的折线 series 索引</span>      <span class="hljs-comment">// 执行其他逻辑</span>      <span class="hljs-comment">// ...</span>    &#125; <span class="hljs-keyword">else</span> &#123;      <span class="hljs-comment">// 执行取消选中逻辑</span>      <span class="hljs-comment">// ...</span>    &#125;  &#125;&#125;;</code></pre>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>干恁娘的百度地图开发体验</title>
    <link href="/20211201-BMapGL_bug/"/>
    <url>/20211201-BMapGL_bug/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/87812944_p0.jpg" srcset="/img/loading.gif" alt="nekomimi"></p><p>第一次在项目里接触地图开发，虽然直接使用了百度地图的 API，但还是遇到了不少问题，而且缺少最佳实践参考，很多逻辑都是自己设计实现，渲染性能也有点低。不过最大的问题是整出了内存泄漏，麻烦死了</p><h2 id="最大问题之内存泄漏"><a href="#最大问题之内存泄漏" class="headerlink" title="最大问题之内存泄漏"></a>最大问题之内存泄漏</h2><p>虽然没有做严格测试，但基本可以确定是百度地图删除覆盖物内存未释放导致的问题，花了好些天才比较完美地绕过了这个 Bug，记录一下</p><h3 id="问题定位"><a href="#问题定位" class="headerlink" title="问题定位"></a>问题定位</h3><ol><li>刚开始以为是自定义标记的写法不对导致了内存泄漏，果断放弃了自定义标记，依然漏</li><li>开始详细排查，怀疑是 Redux 闹鬼，分步注释代码，干恁娘发现 Redux 状态更新导致了重复渲染，又着手解决重复渲染问题，最后确定 useSelector 不能用默认的全等比较，传入自带的 shallowEqual 解决问题</li><li>解决 Redux 问题后确认地图覆盖物刷新导致泄漏，开始按图层分析</li><li>预警点图标刷新并未导致泄漏，绑定的事件监听也不会漏，也没有闭包问题，确认问题出在路径折线渲染</li></ol><h3 id="尝试解决"><a href="#尝试解决" class="headerlink" title="尝试解决"></a>尝试解决</h3><ol><li>定位问题花了好几天，解决问题思路倒是简单，既然不能反复添加删除，那就循环利用</li></ol><pre><code class="hljs text">初始化时保存一个折线对象数组，作为内存池，刷新时直接取内存池里已有的折线改变属性多余的折线设置一个看不见的点位藏起来，不够的折线另外申请内存并推入对象数组</code></pre><h3 id="一波三折"><a href="#一波三折" class="headerlink" title="一波三折"></a>一波三折</h3><blockquote><p>看起来似乎很完美的解决方案，结果又被百度地图摆了一道</p></blockquote><p>内存泄漏的问题的确迎刃而解，皆大欢喜，不漏了，<strong><em>但 是</em></strong></p><p>尼玛坑爹的地图，修改折线属性、换绑点击事件之后，地图的折线干恁娘的不刷新，而且有时候还会莫名其妙的消失不见，必须拖动或者缩放一下地图才会真正刷新——我去年买了个包超耐磨</p><h3 id="最终原子爆炸"><a href="#最终原子爆炸" class="headerlink" title="最终原子爆炸"></a>最终原子爆炸</h3><blockquote><p>既然你自己不刷，无他，我强制你刷</p><blockquote><p>笑死，百度地图根本没有强制刷新的 API</p></blockquote></blockquote><p>好家伙，只能另辟蹊径了，尝试了以下几种方式</p><ol><li>修改完属性后重置折线显隐状态（无效）</li><li>修改完重置折线颜色（无效）</li><li>修改完请来 setTimeout 异步重置折线颜色（有用，草泥马燃起来了）</li><li>所有修改都异步进行（无效，淦）</li></ol><p>最后，采用第三种方式解决了问题，不过值得注意的是，折线刷新的时候颜色会出现闪烁，推测这里的异步处理导致了颜色刷新的时间差</p><p>Anyway，解决了最大的 Boss，不漏了，鼓掌</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>旧版本CRA打包构建速度优化</title>
    <link href="/building_speed/"/>
    <url>/building_speed/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/gura.jpg" srcset="/img/loading.gif" alt="gura"></p><p>公司项目由于使用的 react-scripts 版本太老，试了一下没办法一步升级到最新版本，每次打包都得花 15 分钟左右，实在是急死人。</p><p>最近实在忍不住了，尝试对打包速度进行了优化。走了一些弯路，但是最后打包时间缩短到了 1 分钟，还是非常欣慰的。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>首先弄清楚优化思路很重要，webpack 可以使用 SMP(speed-measure-webpack-plugin) 对打包时间进行记录，打包完成后会显示每个 loader 和插件运行耗费的时间，然后针对耗时高的 loader 和插件进行优化。</p><h2 id="具体方法"><a href="#具体方法" class="headerlink" title="具体方法"></a>具体方法</h2><p>分析了很久才发现打包耗时是因为 uglify 实在是太慢了，各大代码平台也提到了这个问题，本来想通过升级整体架构来解决，但是遇到的冲突太多了，不得不另想办法。</p><h3 id="重点针对-uglify-进行优化"><a href="#重点针对-uglify-进行优化" class="headerlink" title="重点针对 uglify 进行优化"></a>重点针对 uglify 进行优化</h3><p>uglify 的优化思路其实很简单，多线程 + 缓存。</p><ol><li>使用 <code>webpack-parallel-uglify-plugin</code> 代替原有的 uglify 插件</li></ol><p>安装插件前还要注意版本，太新的版本可能不兼容</p><blockquote><p>注意如果使用 config-override 进行配置，需要对原有的 uglify 插件进行覆盖</p></blockquote><ol><li>使用 ParallelUglifyPlugin 的配置时要注意可能对代码造成的侵入性改动，建议关闭不必要的优化选项</li></ol><h3 id="针对-babel-loader-进行优化"><a href="#针对-babel-loader-进行优化" class="headerlink" title="针对 babel-loader 进行优化"></a>针对 babel-loader 进行优化</h3><p>babel 其实也是比较耗时的，尝试用 <code>esbuild-loader</code> 替换 <code>babel-loader</code> 之后发现，<code>esbuild-loader</code> 并不支持直接转换 ES6 代码，而项目本身的代码质量过低，没办法直接使用 <code>esbuild-loader</code> 进行构建，所以使用 <code>thread-loader</code> 开启 babel-loader 多线程。</p><h2 id="配置参考"><a href="#配置参考" class="headerlink" title="配置参考"></a>配置参考</h2><pre><code class="hljs js"><span class="hljs-comment">// /config-overrides.js</span><span class="hljs-keyword">const</span> &#123; injectBabelPlugin, getBabelLoader &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-app-rewired'</span>);<span class="hljs-keyword">const</span> rewireLess = <span class="hljs-built_in">require</span>(<span class="hljs-string">'react-app-rewire-less'</span>);<span class="hljs-keyword">const</span> ParallelUglifyPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'webpack-parallel-uglify-plugin'</span>);<span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">'path'</span>);<span class="hljs-keyword">const</span> &#123; override, addWebpackAlias, disableEsLint &#125; = <span class="hljs-built_in">require</span>(<span class="hljs-string">'customize-cra'</span>);<span class="hljs-keyword">const</span> conf = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-function">(<span class="hljs-params">config, env</span>) =&gt;</span> &#123;  <span class="hljs-comment">// ...其他配置</span>  <span class="hljs-comment">// 开启 babel 多线程</span>  <span class="hljs-keyword">const</span> babelLoader = getBabelLoader(config.module.rules);  <span class="hljs-keyword">const</span> &#123; options &#125; = babelLoader;  options.cacheDirectory = <span class="hljs-literal">true</span>;  babelLoader.use = [    &#123; <span class="hljs-attr">loader</span>: <span class="hljs-string">'thread-loader'</span>, <span class="hljs-attr">options</span>: &#123; <span class="hljs-attr">workers</span>: <span class="hljs-number">15</span>, <span class="hljs-attr">workerParallelJobs</span>: <span class="hljs-number">50</span>, <span class="hljs-attr">poolTimeout</span>: <span class="hljs-number">2000</span> &#125; &#125;,    &#123;      loader: babelLoader.loader,      options,    &#125;,  ];  <span class="hljs-keyword">delete</span> babelLoader.loader;  <span class="hljs-keyword">delete</span> babelLoader.options;  <span class="hljs-keyword">if</span> (env === <span class="hljs-string">'production'</span>) &#123;    <span class="hljs-comment">// 开启 uglify 多线程</span>    config.plugins.splice(<span class="hljs-number">3</span>, <span class="hljs-number">1</span>);    config.plugins.push(      <span class="hljs-keyword">new</span> ParallelUglifyPlugin(&#123;        parallel: <span class="hljs-literal">true</span>,        <span class="hljs-comment">// 本质上还是用了 UglifyJS，以下是传给 UglifyJS 的参数，优化的点在于开启了多进程</span>        uglifyJS: &#123;          output: &#123;            beautify: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 使用紧凑的输出</span>            comments: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 删除所有的注释</span>          &#125;,          compress: &#123;            drop_console: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 删除所有 console</span>            collapse_vars: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 内嵌定义了但是只用到一次的变量</span>            reduce_vars: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 提取出出现多次，但是没有定义成变量去引用的静态值</span>            unused: <span class="hljs-literal">false</span>, <span class="hljs-comment">// 提取未使用的局部变量</span>            drop_debugger: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 删除所有 debugger</span>            keep_fnames: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 保持函数名</span>          &#125;,        &#125;,        cacheDir: <span class="hljs-string">'cache'</span>, <span class="hljs-comment">// 开启缓存</span>      &#125;)    );  &#125;  <span class="hljs-keyword">return</span> config;&#125;;<span class="hljs-built_in">module</span>.exports = override(  <span class="hljs-comment">// ...其他配置</span>  conf(), <span class="hljs-comment">// 将自定义配置组合进来</span>);</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>提到优化，首先还是得分析问题所在，然后尝试不同的方向去解决问题，不能想当然套用别人的优化方式。</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Jointjs 使用总结</title>
    <link href="/use_jointjs/"/>
    <url>/use_jointjs/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/atri.png" srcset="/img/loading.gif" alt=""></p><!-- TOC --><ul><li><a href="#1-jointjs-使用总结">1. Jointjs 使用总结</a><ul><li><a href="#11-版本">1.1. 版本</a></li><li><a href="#12-初始化相关">1.2. 初始化相关</a><ul><li><a href="#121-代码示例">1.2.1. 代码示例</a></li></ul></li><li><a href="#13-图形元素">1.3. 图形元素</a><ul><li><a href="#131-绑定元素点击事件">1.3.1. 绑定元素点击事件</a></li><li><a href="#132-绑定连线的操作工具">1.3.2. 绑定连线的操作工具</a></li><li><a href="#133-shapesstandard-标准插件">1.3.3. shapes.standard 标准插件</a></li><li><a href="#134-连线">1.3.4. 连线</a></li></ul></li><li><a href="#14-通用方法">1.4. 通用方法</a><ul><li><a href="#141-画布导入和导出">1.4.1. 画布导入和导出</a></li><li><a href="#142-常用方法">1.4.2. 常用方法</a></li></ul></li><li><a href="#15-整体代码示例">1.5. 整体代码示例</a></li></ul></li></ul><!-- /TOC --><h1 id="1-Jointjs-使用总结"><a href="#1-Jointjs-使用总结" class="headerlink" title="1. Jointjs 使用总结"></a>1. Jointjs 使用总结</h1><p>Jointjs 是一个使用 svg 绘制流程图、拓扑关系图的 JS 库，比起 G6 引擎来说，jointjs 的接口使用更直观，最终呈现效果也比较理想，特别是 Link 类型连线的自带工具非常好用，完美契合开发需求。但是这个库比较冷门，中文资料不多，而且多数都是踩坑记录，事实上我实际用起来也是踩了无数的坑，心累</p><h2 id="1-1-版本"><a href="#1-1-版本" class="headerlink" title="1.1. 版本"></a>1.1. 版本</h2><p>目前官方最新版本为 3.3.1，项目里的 webpack 版本比较老，直接使用 npm 安装 3.3.1 会出现打包失败的情况，推测是因为最新版本引用的某个库代码兼容性不够导致的，所以以下内容均基于 3.1.0 版本。</p><blockquote><p>文档相关链接</p></blockquote><p>官方文档，版本不能切换时直接修改链接地址的版本 <a href="https://resources.jointjs.com/docs/jointjs/v3.3/joint.html" target="_blank" rel="noopener">https://resources.jointjs.com/docs/jointjs/v3.3/joint.html</a></p><p>旧版文档翻译参考 <a href="https://segmentfault.com/a/1190000004579894" target="_blank" rel="noopener">https://segmentfault.com/a/1190000004579894</a></p><p>事件类型参考 <a href="https://blog.csdn.net/qq_39324050/article/details/109530753" target="_blank" rel="noopener">https://blog.csdn.net/qq_39324050/article/details/109530753</a></p><p>svg 文档 <a href="https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan" target="_blank" rel="noopener">https://developer.mozilla.org/en-US/docs/Web/SVG/Element/tspan</a></p><h2 id="1-2-初始化相关"><a href="#1-2-初始化相关" class="headerlink" title="1.2. 初始化相关"></a>1.2. 初始化相关</h2><ol><li><p>使用 import 方式引入</p><ul><li><code>npm i jointjs -S</code>，自带 jQuery、backbone、lodash，如果使用 script 标签引入，需要手动引入这些依赖</li><li><code>import * as joint from &#39;jointjs&#39;</code> 整体引入（常用）</li><li><code>import { dia } from &#39;jointjs/src/core.mjs&#39;</code> 按需引入</li></ul><p>项目里只用了 import 方式引入，所以也导致踩了一系列坑，建议尝试用 script 全局引入，坑应该少一点（x</p></li><li><p>初始化画布</p></li></ol><blockquote><p>坑注意：import 方式引入的时候，joint 全局变量是没有全局挂载的，所以必须手动传入 cellNamespace 参数，不然报错</p></blockquote><p>ES6 引入时命名空间报错问题参考 <a href="https://stackoverflow.com/questions/57428402/getting-error-dia-elementview-markup-required-from-graph-fromjsonjson" target="_blank" rel="noopener">https://stackoverflow.com/questions/57428402/getting-error-dia-elementview-markup-required-from-graph-fromjsonjson</a></p><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joint <span class="hljs-keyword">from</span> <span class="hljs-string">"jointjs"</span>;<span class="hljs-comment">// 初始化画布模型，使用 ES6 引入 jointjs 时，joint 全局变量未注册，必须传入 cellNamespace 参数</span><span class="hljs-keyword">const</span> graph = <span class="hljs-keyword">new</span> joint.dia.Graph(&#123;&#125;, &#123; <span class="hljs-attr">cellNamespace</span>: joint.shapes &#125;);<span class="hljs-comment">// 初始化画布视图</span><span class="hljs-keyword">const</span> element = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"paper"</span>);<span class="hljs-keyword">const</span> height = element.clientHeight;<span class="hljs-keyword">const</span> width = element.clientWidth;<span class="hljs-keyword">const</span> paper = <span class="hljs-keyword">new</span> joint.dia.Paper(&#123;  <span class="hljs-comment">// 挂载的 dom 元素</span>  el: element,  <span class="hljs-comment">// 关联声明的 graph</span>  model: graph,  <span class="hljs-comment">// 画布大小，初始化之后还可以动态调整，项目里没试过，自行查资料</span>  width,  height,  defaultAnchor: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">"perpendicular"</span> &#125;,  gridSize: <span class="hljs-number">5</span>, <span class="hljs-comment">// 画布上元素拖动时步进的为5像素，默认1</span>  drawGrid: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 显示步进点，方便对齐，3.1.0 版本貌似不起作用？</span>  <span class="hljs-comment">// snapLinks: &#123;</span>  <span class="hljs-comment">//   radius: 5, // 距离元素连接点 5 像素时自动连接上</span>  <span class="hljs-comment">// &#125;,</span>  snapLinks: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 坑注意，3.1.0 版本设置像素值时会以元素中心点来计算范围，像上面设置为 5，范围就会特别小</span>  interactive: &#123;    <span class="hljs-comment">// 禁用元素拖拽、连线标签拖拽</span>    elementMove: <span class="hljs-literal">true</span>,    labelMove: <span class="hljs-literal">true</span>,    linkMove: <span class="hljs-literal">true</span>,    arrowheadMove: <span class="hljs-literal">true</span>,  &#125;,  cellViewNamespace: joint.shapes, <span class="hljs-comment">// 注意必须同步传入 cellViewNamespace 参数</span>  <span class="hljs-comment">// linkConnectionPoint: joint.util.shapePerimeterConnectionPoint, // 链接将尝试在连接形状的周长上找到最佳的连接点，而不仅仅是在边界框上（3.1.0 貌似不起作用）</span>&#125;);</code></pre><ol><li><p>清除画布所有元素</p><ul><li><code>graph.clear()</code> 清除元素</li><li><code>paper.remove()</code> 这两个没具体研究，但是 paper.remove 好像同时会清理绑定的监听事件，一般我会同时调用这两个方法来清空画布</li></ul></li><li><p>画布缩放平移</p></li></ol><p>jointjs 底层是用 svg 实现的，本身没有自带缩放平移的方法，需要手动绑定</p><p>平移参考 <a href="https://stackoverflow.com/questions/28431384/how-to-make-a-paper-draggable" target="_blank" rel="noopener">https://stackoverflow.com/questions/28431384/how-to-make-a-paper-draggable</a></p><p>缩放参考找不到了</p><h3 id="1-2-1-代码示例"><a href="#1-2-1-代码示例" class="headerlink" title="1.2.1. 代码示例"></a>1.2.1. 代码示例</h3><blockquote><p>多个动作需要绑定相同事件时，用空格分割，栗子：<code>&#39;blank:pointerup blank:mouseout&#39;</code></p></blockquote><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 绑定鼠标滚轮缩放事件</span><span class="hljs-comment"> */</span>bindMouseWheel() &#123;  <span class="hljs-comment">// 注意两个事件的回调参数不一致</span>  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:mousewheel'</span>, (e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'element:mousewheel'</span>, (cellView, e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 复制代码，抄就行了不解释</span><span class="hljs-comment"> */</span>handleCellMouseWheel(e, x, y, delta) &#123;  e.preventDefault();  <span class="hljs-keyword">const</span> oldScale = <span class="hljs-keyword">this</span>.paper.scale().sx;  <span class="hljs-keyword">const</span> newScale = oldScale + delta * <span class="hljs-number">0.1</span>;  <span class="hljs-keyword">this</span>.scaleToPoint(newScale, x, y);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 复制代码</span><span class="hljs-comment"> */</span>scaleToPoint(nextScale, x, y) &#123;  <span class="hljs-keyword">if</span> (nextScale &gt;= MIN_SCALE &amp;&amp; nextScale &lt;= MAX_SCALE) &#123;    <span class="hljs-keyword">const</span> currentScale = <span class="hljs-keyword">this</span>.paper.scale().sx;    <span class="hljs-keyword">const</span> beta = currentScale / nextScale;    <span class="hljs-keyword">const</span> ax = x - x * beta;    <span class="hljs-keyword">const</span> ay = y - y * beta;    <span class="hljs-keyword">const</span> translate = <span class="hljs-keyword">this</span>.paper.translate();    <span class="hljs-keyword">const</span> nextTx = translate.tx - ax * nextScale;    <span class="hljs-keyword">const</span> nextTy = translate.ty - ay * nextScale;    <span class="hljs-keyword">this</span>.paper.translate(nextTx, nextTy);    <span class="hljs-keyword">const</span> ctm = <span class="hljs-keyword">this</span>.paper.matrix();    ctm.a = nextScale;    ctm.d = nextScale;    <span class="hljs-keyword">this</span>.paper.matrix(ctm);  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 绑定画布平移事件，mousedown 记录当前画布位置坐标（并计算缩放比），mouseup 清除当前画布位置坐标</span><span class="hljs-comment"> * 画布本身未定义鼠标移动相关事件，所以利用 dom 监听 mousemove 事件，将鼠标移动参数转换为画布移动</span><span class="hljs-comment"> * 组件卸载时要调用 destroy 事件清除事件监听</span><span class="hljs-comment"> */</span>bindDragPaper() &#123;  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerdown'</span>, (e, x, y) =&gt; &#123;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();    <span class="hljs-keyword">this</span>.dragPosition = [x * scale.sx, y * scale.sy];    <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);    <span class="hljs-keyword">this</span>.element.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc.bind(<span class="hljs-keyword">this</span>));  &#125;);  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup blank:mouseout'</span>, (e) =&gt; &#123;    <span class="hljs-keyword">this</span>.dragPosition = [];    <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);  &#125;);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 转换画布平移坐标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>e mousemove 事件回调对象</span><span class="hljs-comment"> */</span>dragFunc(e) &#123;  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dragPosition.length) &#123;    <span class="hljs-keyword">this</span>.paper.translate(e.offsetX - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">0</span>], e.offsetY - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">1</span>]);  &#125;&#125;</code></pre><p>附录</p><ol><li><p>禁止标签拖动，参考 <a href="https://stackoverflow.com/questions/45382941/in-jointjs-how-to-prevent-element-with-ports-from-being-moved-but-still-allow" target="_blank" rel="noopener">https://stackoverflow.com/questions/45382941/in-jointjs-how-to-prevent-element-with-ports-from-being-moved-but-still-allow</a></p></li><li><p>自定义元素引用报错，参考 <a href="https://github.com/clientIO/joint/issues/1281" target="_blank" rel="noopener">https://github.com/clientIO/joint/issues/1281</a></p></li></ol><h2 id="1-3-图形元素"><a href="#1-3-图形元素" class="headerlink" title="1.3. 图形元素"></a>1.3. 图形元素</h2><h3 id="1-3-1-绑定元素点击事件"><a href="#1-3-1-绑定元素点击事件" class="headerlink" title="1.3.1. 绑定元素点击事件"></a>1.3.1. 绑定元素点击事件</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 绑定元素点击事件</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function&#125;</span> </span>callback 回调函数</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>highlight 点击元素是否高亮</span><span class="hljs-comment"> */</span>bindClick(callback, highlight) &#123;  <span class="hljs-keyword">const</span> bindFunc = <span class="hljs-function">(<span class="hljs-params">cellView, evt, x, y</span>) =&gt;</span> &#123;    <span class="hljs-keyword">const</span> cells = <span class="hljs-keyword">this</span>.graph.getCells();    cells.forEach(<span class="hljs-function">(<span class="hljs-params">cell</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 取消其他元素高亮</span>      <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">this</span>.paper.findViewByModel(cell);      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> view.unhighlight === <span class="hljs-string">'function'</span>) &#123;        view.unhighlight();      &#125;    &#125;);    <span class="hljs-comment">// 高亮当前点击的元素</span>    <span class="hljs-keyword">if</span> (cellView &amp;&amp; highlight) &#123;      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.highlight === <span class="hljs-string">'function'</span>) &#123;        cellView.highlight();      &#125;    &#125;    <span class="hljs-comment">// 点击事件回调</span>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) &#123;      callback(cellView);    &#125;  &#125;;  <span class="hljs-comment">// 绑定元素点击事件，坑注意：绑定 pointerclick 会有无法触发的 bug，所以退而监听 pointerup</span>  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'cell:pointerup link:pointerup'</span>, (cellView, evt, x, y) =&gt; bindFunc(cellView, evt, x, y));  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup'</span>, (evt, x, y) =&gt; bindFunc(<span class="hljs-literal">null</span>, evt, x, y));&#125;</code></pre><h3 id="1-3-2-绑定连线的操作工具"><a href="#1-3-2-绑定连线的操作工具" class="headerlink" title="1.3.2. 绑定连线的操作工具"></a>1.3.2. 绑定连线的操作工具</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@description </span>绑定连线相关属性，参考官方手册</span><span class="hljs-comment"> */</span>bindLinkEvent() &#123;  <span class="hljs-comment">// 绑定连线的操作</span>  <span class="hljs-keyword">const</span> verticesTool = <span class="hljs-keyword">new</span> joint.linkTools.Vertices();  <span class="hljs-keyword">const</span> segmentsTool = <span class="hljs-keyword">new</span> joint.linkTools.Segments();  <span class="hljs-keyword">const</span> sourceArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceArrowhead();  <span class="hljs-keyword">const</span> targetArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetArrowhead();  <span class="hljs-keyword">const</span> sourceAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceAnchor();  <span class="hljs-keyword">const</span> targetAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetAnchor();  <span class="hljs-keyword">const</span> boundaryTool = <span class="hljs-keyword">new</span> joint.linkTools.Boundary();  <span class="hljs-keyword">const</span> removeButton = <span class="hljs-keyword">new</span> joint.linkTools.Remove();  <span class="hljs-keyword">const</span> toolsView = <span class="hljs-keyword">new</span> joint.dia.ToolsView(&#123;    tools: [      verticesTool,      segmentsTool,      sourceArrowheadTool,      targetArrowheadTool,      sourceAnchorTool,      targetAnchorTool,      boundaryTool,      removeButton,    ],  &#125;);  <span class="hljs-comment">// 鼠标移入时显示工具，移除时隐藏工具</span>  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseenter'</span>, (linkView) =&gt; &#123;    linkView.addTools(toolsView);    linkView.showTools(toolsView);  &#125;);  <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseleave'</span>, (linkView) =&gt; &#123;    <span class="hljs-comment">// 坑注意：3.1.0 版本不能用 addTools 和 removeTools 搭配，不然工具会 bug，显示不全</span>    linkView.hideTools();  &#125;);&#125;</code></pre><h3 id="1-3-3-shapes-standard-标准插件"><a href="#1-3-3-shapes-standard-标准插件" class="headerlink" title="1.3.3. shapes.standard 标准插件"></a>1.3.3. shapes.standard 标准插件</h3><p>具体各个插件的用法可以参考官方文档</p><pre><code class="hljs js"><span class="hljs-keyword">const</span> standard = joint.shapes.standard;<span class="hljs-keyword">const</span> rectangle = <span class="hljs-keyword">new</span> standard.Rectangle();<span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> standard.Circle();<span class="hljs-keyword">const</span> ellipse = <span class="hljs-keyword">new</span> standard.Ellipse();<span class="hljs-keyword">const</span> path = <span class="hljs-keyword">new</span> standard.Path();<span class="hljs-keyword">const</span> polygon = <span class="hljs-keyword">new</span> standard.Polygon();<span class="hljs-keyword">const</span> polyline = <span class="hljs-keyword">new</span> standard.Polyline();<span class="hljs-keyword">const</span> cylinder = <span class="hljs-keyword">new</span> standard.Cylinder();<span class="hljs-keyword">const</span> image = <span class="hljs-keyword">new</span> standard.Image();<span class="hljs-keyword">const</span> borderedImage = <span class="hljs-keyword">new</span> standard.BorderedImage();<span class="hljs-keyword">const</span> embeddedImage = <span class="hljs-keyword">new</span> standard.EmbeddedImage();<span class="hljs-keyword">const</span> headeredRectangle = <span class="hljs-keyword">new</span> standard.HeaderedRectangle();<span class="hljs-keyword">const</span> textBlock = <span class="hljs-keyword">new</span> standard.TextBlock();<span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> standard.Link();<span class="hljs-keyword">const</span> doubleLink = <span class="hljs-keyword">new</span> standard.DoubleLink();<span class="hljs-keyword">const</span> shadowLink = <span class="hljs-keyword">new</span> standard.ShadowLink();</code></pre><blockquote><p>使用方式以 circle 为例</p></blockquote><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 坐标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> <span class="hljs-variable">y</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>元素在画布上的唯一 ID</span><span class="hljs-comment"> */</span>addCircle(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>) &#123;  <span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> joint.shapes.standard.Circle();  circle.resize(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>); <span class="hljs-comment">// 元素大小</span>  circle.position(x, y); <span class="hljs-comment">// 元素位置</span>  circle.attr(<span class="hljs-string">'root/title'</span>, <span class="hljs-string">'测试元素'</span>); <span class="hljs-comment">// 设置 dom 的 title 属性</span>  circle.attr(<span class="hljs-string">'label/text'</span>, <span class="hljs-string">'hello\nworld'</span>); <span class="hljs-comment">// 文字，注意 svg 控制换行非常麻烦，用 \n 能够解决换行的问题</span>  circle.attr(<span class="hljs-string">'label/fontSize'</span>, <span class="hljs-string">'25'</span>); <span class="hljs-comment">// 文字大小</span>  circle.attr(<span class="hljs-string">'body/fill'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 背景颜色</span>  circle.attr(<span class="hljs-string">'body/stroke'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 边框颜色</span>  circle.attr(<span class="hljs-string">'label/fill'</span>, <span class="hljs-string">'#fff'</span>); <span class="hljs-comment">// 文字颜色</span>  <span class="hljs-keyword">this</span>.graph.addCell(circle); <span class="hljs-comment">// 单个添加</span>  <span class="hljs-comment">// this.graph.addCells([circle]); // 也可以批量添加</span>  <span class="hljs-keyword">if</span> (id) &#123;    <span class="hljs-comment">// 回显画布时，也可以覆盖元素自身生成的 ID</span>    circle.prop([<span class="hljs-string">'id'</span>], id);  &#125;  <span class="hljs-keyword">return</span> circle.id;  <span class="hljs-comment">// joint.util.breakText('this is quite a long text', &#123; width: 50 &#125;) 自动根据宽度换行，3.1.0 貌似不起作用</span>&#125;</code></pre><blockquote><p>使用方式分析</p></blockquote><ol><li>画布添加元素有两种方法，批量添加和单个添加</li><li>元素的属性设置可以使用两种方法，一般推荐使用 <code>item.attr()</code> 方法操作相应属性，但是有些上层属性是不属于 attr 方法的，比如连线的相关属性，此时可以尝试使用 <code>item.prop([...], ...)</code> 操作属性，其中第一个数组参数代表属性的层级，与 <code>attr</code> 方法的斜杠划分意义相同</li></ol><h3 id="1-3-4-连线"><a href="#1-3-4-连线" class="headerlink" title="1.3.4. 连线"></a>1.3.4. 连线</h3><p>连线单独列出来，因为连线的操作比较复杂，jointjs 本身是支持元素之间直接新建连接，没研究透，不会用</p><p>注意连线的标签属性在上层对象里，需要使用 <code>item.prop()</code> 方法进行控制</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 添加连接线</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 初始坐标</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 初始坐标</span><span class="hljs-comment"> */</span>addLink(x = <span class="hljs-number">50</span>, y = <span class="hljs-number">50</span>) &#123;  <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> joint.shapes.standard.Link();  link.source(&#123; x, y &#125;); <span class="hljs-comment">// 起点，可以传元素字符串 ID</span>  <span class="hljs-comment">// link.source(id);</span>  link.target(&#123; <span class="hljs-attr">x</span>: x + <span class="hljs-number">80</span>, y &#125;); <span class="hljs-comment">// 终点</span>  link.labels([    &#123;      attrs: &#123;        text: &#123;          text: <span class="hljs-string">''</span>, <span class="hljs-comment">// 标签文字</span>        &#125;,      &#125;,    &#125;,  ]);  link.attr(<span class="hljs-string">'line/stroke'</span>, <span class="hljs-string">'#2f76ff'</span>); <span class="hljs-comment">// 线条颜色</span>  link.prop([<span class="hljs-string">'doubleLinkTools'</span>], <span class="hljs-string">'true'</span>); <span class="hljs-comment">// 显示双箭头</span>  link.prop([<span class="hljs-string">'labels'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'attrs'</span>, <span class="hljs-string">'rect'</span>, <span class="hljs-string">'fill'</span>], <span class="hljs-string">'rgba(0, 0, 0, 0)'</span>); <span class="hljs-comment">// 标签背景矩形的颜色</span>  <span class="hljs-keyword">this</span>.graph.addCell(link);&#125;</code></pre><h2 id="1-4-通用方法"><a href="#1-4-通用方法" class="headerlink" title="1.4. 通用方法"></a>1.4. 通用方法</h2><h3 id="1-4-1-画布导入和导出"><a href="#1-4-1-画布导入和导出" class="headerlink" title="1.4.1. 画布导入和导出"></a>1.4.1. 画布导入和导出</h3><p>jointjs 支持直接将画布导出为 json 对象，也可以将对象导入到画布上</p><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 导出画布元素</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">JSON</span></span></span><span class="hljs-comment"> */</span>exportGraph() &#123;  <span class="hljs-keyword">const</span> jsonData = <span class="hljs-keyword">this</span>.graph.toJSON();  <span class="hljs-keyword">return</span> jsonData;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 导入画布数据，JSON 对象，注意并非 JSON 字符串</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>jsonData JSON</span><span class="hljs-comment"> * <span class="hljs-doctag">@example <span class="hljs-type">&#123;"cells": [&#123;...&#125;</span></span>, &#123;...&#125;]&#125;</span><span class="hljs-comment"> */</span>importGraph(jsonData) &#123;  <span class="hljs-keyword">this</span>.graph.fromJSON(jsonData);&#125;</code></pre><h3 id="1-4-2-常用方法"><a href="#1-4-2-常用方法" class="headerlink" title="1.4.2. 常用方法"></a>1.4.2. 常用方法</h3><pre><code class="hljs js"><span class="hljs-comment">/**</span><span class="hljs-comment"> * 移除单个元素</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>cellView 元素对象，视图对象或者模型对象均可，可以使用下述 getCellByID() 方法来获取</span><span class="hljs-comment"> */</span>removeItem(cellView) &#123;  <span class="hljs-keyword">if</span> (cellView.model &amp;&amp; <span class="hljs-keyword">typeof</span> cellView.model.remove === <span class="hljs-string">'function'</span>) &#123;    cellView.model.remove();  &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.remove === <span class="hljs-string">'function'</span>) &#123;    cellView.remove();  &#125;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取当前画布所有元素，和导出画布好像差不多</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Array&#125;</span> </span>元素数组</span><span class="hljs-comment"> */</span>getCells() &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCells();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 用元素 ID 获取元素视图对象，可以用于操作元素属性、删除元素</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">id</span></span></span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> </span>元素视图对象</span><span class="hljs-comment"> */</span>getCellByID(id) &#123;  <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCell(id);&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 获取画布当前的缩放比例和平移位置</span><span class="hljs-comment"> * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-type">&#123;scale, position&#125;</span></span></span><span class="hljs-comment"> */</span>getPaperScaleAndPos() &#123;  <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();  <span class="hljs-keyword">const</span> position = <span class="hljs-keyword">this</span>.paper.translate();  <span class="hljs-keyword">return</span> &#123; scale, position &#125;;&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 清除当前画布</span><span class="hljs-comment"> */</span>clearGraph() &#123;  <span class="hljs-keyword">this</span>.graph.clear();&#125;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 销毁当前画布，并且销毁画布所有监听事件</span><span class="hljs-comment"> */</span>destroy() &#123;  <span class="hljs-keyword">this</span>.clearGraph();  <span class="hljs-keyword">this</span>.paper.remove();  <span class="hljs-comment">// 移除画布平移绑定的 dom 事件</span>  <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);&#125;</code></pre><h2 id="1-5-整体代码示例"><a href="#1-5-整体代码示例" class="headerlink" title="1.5. 整体代码示例"></a>1.5. 整体代码示例</h2><p>项目需求比较简单，所以也没做彻底研究，写的类也只能基本适应简单需求，权当参考，自定义元素这部分实在没理解透，只能退而求其次使用单独添加渲染的方式来自定义元素，逻辑也就显得有点啰嗦了</p><pre><code class="hljs js"><span class="hljs-comment">/* eslint-disable class-methods-use-this */</span><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> joint <span class="hljs-keyword">from</span> <span class="hljs-string">'jointjs'</span>;<span class="hljs-keyword">import</span> _ <span class="hljs-keyword">from</span> <span class="hljs-string">'lodash'</span>;<span class="hljs-keyword">import</span> $ <span class="hljs-keyword">from</span> <span class="hljs-string">'jquery'</span>;<span class="hljs-keyword">const</span> MIN_SCALE = <span class="hljs-number">0.1</span>;<span class="hljs-keyword">const</span> MAX_SCALE = <span class="hljs-number">10</span>;<span class="hljs-comment">/**</span><span class="hljs-comment"> * <span class="hljs-doctag">@classdesc </span>jointjs 封装</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>id 绑定的 dom ID</span><span class="hljs-comment"> * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>elementMove 是否禁用元素拖拽</span><span class="hljs-comment"> * <span class="hljs-doctag">@date </span>2021-05-8</span><span class="hljs-comment"> * <span class="hljs-doctag">@author <span class="hljs-variable">zhw</span></span></span><span class="hljs-comment"> */</span><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JointJS</span> </span>&#123;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>画布模型对象</span><span class="hljs-comment">   */</span>  graph = <span class="hljs-literal">null</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>画布视图对象</span><span class="hljs-comment">   */</span>  paper = <span class="hljs-literal">null</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>画布渲染绑定的 dom 对象</span><span class="hljs-comment">   */</span>  element = <span class="hljs-literal">null</span>;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>自定义元素组</span><span class="hljs-comment">   */</span>  customElement = &#123;&#125;;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@desc </span>拖拽画布时保存画布初始位置，用于计算拖拽距离</span><span class="hljs-comment">   */</span>  dragPosition = [];  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>id 绑定的 dom ID</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>elementMove 是否禁用元素拖拽</span><span class="hljs-comment">   */</span>  <span class="hljs-keyword">constructor</span>(id, elementMove = true) &#123;    <span class="hljs-keyword">try</span> &#123;      <span class="hljs-keyword">this</span>.element = <span class="hljs-built_in">document</span>.getElementById(id);      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.element) &#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'找不到挂载点'</span>);      &#125;      <span class="hljs-keyword">this</span>.initGraph();      <span class="hljs-keyword">this</span>.initPaper(elementMove);      <span class="hljs-keyword">this</span>.initCustomElement();      <span class="hljs-keyword">this</span>.bindEvent();    &#125; <span class="hljs-keyword">catch</span> (e) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'jointjs error:'</span>, e.message);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>初始化画布模型，使用 ES6 引入 jointjs 时，joint 全局变量未注册，必须传入 cellNamespace 参数</span><span class="hljs-comment">   */</span>  initGraph() &#123;    <span class="hljs-keyword">this</span>.graph = <span class="hljs-keyword">new</span> joint.dia.Graph(&#123;&#125;, &#123; <span class="hljs-attr">cellNamespace</span>: joint.shapes &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>初始化画布视图，必须传入 cellViewNamespace 参数</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;boolean&#125;</span> </span>movable 元素是否可拖拽</span><span class="hljs-comment">   */</span>  initPaper(movable) &#123;    <span class="hljs-keyword">const</span> height = <span class="hljs-keyword">this</span>.element.clientHeight;    <span class="hljs-keyword">const</span> width = <span class="hljs-keyword">this</span>.element.clientWidth;    <span class="hljs-keyword">this</span>.paper = <span class="hljs-keyword">new</span> joint.dia.Paper(&#123;      <span class="hljs-comment">// 挂载的 dom 元素</span>      el: <span class="hljs-keyword">this</span>.element,      <span class="hljs-comment">// 关联声明的 graph</span>      model: <span class="hljs-keyword">this</span>.graph,      width,      height,      defaultAnchor: &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'perpendicular'</span> &#125;,      gridSize: <span class="hljs-number">5</span>, <span class="hljs-comment">// 画布上元素拖动时步进的为5像素，默认1</span>      drawGrid: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 显示步进点，方便对齐</span>      <span class="hljs-comment">// snapLinks: &#123;</span>      <span class="hljs-comment">//   radius: 5, // 距离元素连接点 5 像素时自动连接上</span>      <span class="hljs-comment">// &#125;,</span>      snapLinks: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 坑注意，3.1 版本设置像素值时会以元素中心点来计算范围</span>      interactive: &#123; <span class="hljs-attr">elementMove</span>: movable, <span class="hljs-attr">labelMove</span>: movable, <span class="hljs-attr">linkMove</span>: movable, <span class="hljs-attr">arrowheadMove</span>: movable &#125;, <span class="hljs-comment">// 禁用元素拖拽、连线标签拖拽</span>      cellViewNamespace: joint.shapes,      <span class="hljs-comment">// linkConnectionPoint: joint.util.shapePerimeterConnectionPoint, // 链接将尝试在连接形状的周长上找到最佳的连接点，而不仅仅是在边界框上（貌似不起作用）</span>    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>初始化自定义元素</span><span class="hljs-comment">   * 由于元素无法绑定在 joint.shapes 上，所以用 this.customElement 保存自定义元素设置，在导入 graph JSON 时，自定义元素只能手动添加</span><span class="hljs-comment">   */</span>  initCustomElement() &#123;    <span class="hljs-comment">// 此处自定义了一个带有标题头部的矩形元素</span>    <span class="hljs-keyword">this</span>.customElement.HeaderRect = joint.dia.Element.define(<span class="hljs-string">'standard.Header'</span>, &#123;      <span class="hljs-comment">// default attributes</span>      <span class="hljs-comment">// markup 为元素模型参数，tagName 决定 svg 元素类型，selector 为属性选择器名称。整体类似于用 html 标签写的布局框架，后续 attrs 等参数设置相应 svg 标签的属性</span>      markup: [        &#123;          tagName: <span class="hljs-string">'rect'</span>,          selector: <span class="hljs-string">'header'</span>,        &#125;,        &#123;          tagName: <span class="hljs-string">'rect'</span>,          selector: <span class="hljs-string">'body'</span>,        &#125;,        &#123;          tagName: <span class="hljs-string">'text'</span>,          selector: <span class="hljs-string">'headerText'</span>,        &#125;,        &#123;          tagName: <span class="hljs-string">'text'</span>,          selector: <span class="hljs-string">'bodyText'</span>,          children: [            &#123;              tagName: <span class="hljs-string">'tspan'</span>,              selector: <span class="hljs-string">'bodyText1'</span>,            &#125;,            &#123;              tagName: <span class="hljs-string">'tspan'</span>,              selector: <span class="hljs-string">'bodyText2'</span>,            &#125;,          ],        &#125;,      ],      attrs: &#123;        header: &#123;          refWidth: <span class="hljs-string">'100%'</span>, <span class="hljs-comment">// 相对宽度</span>          height: <span class="hljs-number">30</span>, <span class="hljs-comment">// 绝对高度</span>          strokeWidth: <span class="hljs-number">1</span>, <span class="hljs-comment">// 边框宽度</span>          stroke: <span class="hljs-string">'#000000'</span>, <span class="hljs-comment">// 边框颜色</span>          fill: <span class="hljs-string">'#eee'</span>, <span class="hljs-comment">// 背景颜色</span>          fontSize: <span class="hljs-string">'16'</span>, <span class="hljs-comment">// 字体大小</span>        &#125;,        body: &#123;          refWidth: <span class="hljs-string">'100%'</span>,          refHeight: <span class="hljs-string">'70%'</span>, <span class="hljs-comment">// 相对高度</span>          refY: <span class="hljs-number">30</span>, <span class="hljs-comment">// 相对位置</span>          strokeWidth: <span class="hljs-number">1</span>,          stroke: <span class="hljs-string">'#000000'</span>,          fill: <span class="hljs-string">'#fff'</span>,        &#125;,        headerText: &#123;          textVerticalAnchor: <span class="hljs-string">'middle'</span>, <span class="hljs-comment">// 文字垂直对齐</span>          textAnchor: <span class="hljs-string">'middle'</span>, <span class="hljs-comment">// 文字水平对齐</span>          refX: <span class="hljs-string">'50%'</span>,          refY: <span class="hljs-number">15</span>,          fontSize: <span class="hljs-number">16</span>,          fill: <span class="hljs-string">'#000'</span>, <span class="hljs-comment">// 在 tspan, text 标签中，fill 为字体颜色，具体参考 svg 文档</span>        &#125;,        bodyText: &#123;          <span class="hljs-comment">// textAnchor: 'middle',</span>          refX: <span class="hljs-string">'5%'</span>,          refY: <span class="hljs-number">30</span>,          fontSize: <span class="hljs-number">14</span>,          fill: <span class="hljs-string">'#000'</span>,        &#125;,        bodyText1: &#123;          fontSize: <span class="hljs-number">14</span>,          fill: <span class="hljs-string">'red'</span>,        &#125;,        bodyText2: &#123;          fontSize: <span class="hljs-number">14</span>,          fill: <span class="hljs-string">'#000'</span>,        &#125;,      &#125;,    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@protected</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>决定需要绑定哪些画布事件，可重写</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function&#125;</span> </span>callback 仅设置点击事件的回调函数</span><span class="hljs-comment">   */</span>  bindEvent(callback, highlight) &#123;    <span class="hljs-keyword">this</span>.bindMouseWheel();    <span class="hljs-keyword">this</span>.bindDragPaper();    <span class="hljs-keyword">this</span>.bindClick(callback, highlight);    <span class="hljs-keyword">this</span>.bindLinkEvent();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定鼠标滚轮缩放事件</span><span class="hljs-comment">   */</span>  bindMouseWheel() &#123;    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:mousewheel'</span>, (e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'element:mousewheel'</span>, (cellView, e, x, y, delta) =&gt; <span class="hljs-keyword">this</span>.handleCellMouseWheel(e, x, y, delta));  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * 复制代码</span><span class="hljs-comment">   */</span>  handleCellMouseWheel(e, x, y, delta) &#123;    e.preventDefault();    <span class="hljs-keyword">const</span> oldScale = <span class="hljs-keyword">this</span>.paper.scale().sx;    <span class="hljs-keyword">const</span> newScale = oldScale + delta * <span class="hljs-number">0.1</span>;    <span class="hljs-keyword">this</span>.scaleToPoint(newScale, x, y);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * 复制代码</span><span class="hljs-comment">   */</span>  scaleToPoint(nextScale, x, y) &#123;    <span class="hljs-keyword">if</span> (nextScale &gt;= MIN_SCALE &amp;&amp; nextScale &lt;= MAX_SCALE) &#123;      <span class="hljs-keyword">const</span> currentScale = <span class="hljs-keyword">this</span>.paper.scale().sx;      <span class="hljs-keyword">const</span> beta = currentScale / nextScale;      <span class="hljs-keyword">const</span> ax = x - x * beta;      <span class="hljs-keyword">const</span> ay = y - y * beta;      <span class="hljs-keyword">const</span> translate = <span class="hljs-keyword">this</span>.paper.translate();      <span class="hljs-keyword">const</span> nextTx = translate.tx - ax * nextScale;      <span class="hljs-keyword">const</span> nextTy = translate.ty - ay * nextScale;      <span class="hljs-keyword">this</span>.paper.translate(nextTx, nextTy);      <span class="hljs-keyword">const</span> ctm = <span class="hljs-keyword">this</span>.paper.matrix();      ctm.a = nextScale;      ctm.d = nextScale;      <span class="hljs-keyword">this</span>.paper.matrix(ctm);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定画布平移事件，mousedown 记录当前画布位置坐标（并计算缩放比），mouseup 清除当前画布位置坐标</span><span class="hljs-comment">   * 画布本身未定义鼠标移动相关事件，所以利用 dom 监听 mousemove 事件，将鼠标移动参数转换为画布移动</span><span class="hljs-comment">   * 组件卸载时要调用 destroy 事件清除事件监听</span><span class="hljs-comment">   */</span>  bindDragPaper() &#123;    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerdown'</span>, (e, x, y) =&gt; &#123;      <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();      <span class="hljs-keyword">this</span>.dragPosition = [x * scale.sx, y * scale.sy];      <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);      <span class="hljs-keyword">this</span>.element.addEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc.bind(<span class="hljs-keyword">this</span>));    &#125;);    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup blank:mouseout'</span>, (e) =&gt; &#123;      <span class="hljs-keyword">this</span>.dragPosition = [];      <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>转换画布平移坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>e mousemove 事件回调对象</span><span class="hljs-comment">   */</span>  dragFunc(e) &#123;    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.dragPosition.length) &#123;      <span class="hljs-keyword">this</span>.paper.translate(e.offsetX - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">0</span>], e.offsetY - <span class="hljs-keyword">this</span>.dragPosition[<span class="hljs-number">1</span>]);    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定元素点击事件</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;function&#125;</span> </span>callback 回调函数</span><span class="hljs-comment">   */</span>  bindClick(callback, highlight) &#123;    <span class="hljs-keyword">const</span> bindFunc = <span class="hljs-function">(<span class="hljs-params">cellView, evt, x, y</span>) =&gt;</span> &#123;      <span class="hljs-keyword">const</span> cells = <span class="hljs-keyword">this</span>.graph.getCells();      cells.forEach(<span class="hljs-function">(<span class="hljs-params">cell</span>) =&gt;</span> &#123;        <span class="hljs-comment">// 取消其他元素高亮</span>        <span class="hljs-keyword">const</span> view = <span class="hljs-keyword">this</span>.paper.findViewByModel(cell);        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> view.unhighlight === <span class="hljs-string">'function'</span>) &#123;          view.unhighlight();        &#125;      &#125;);      <span class="hljs-comment">// 高亮当前点击的元素</span>      <span class="hljs-keyword">if</span> (cellView &amp;&amp; highlight) &#123;        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.highlight === <span class="hljs-string">'function'</span>) &#123;          cellView.highlight();        &#125;      &#125;      <span class="hljs-comment">// 点击事件回调</span>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> callback === <span class="hljs-string">'function'</span>) &#123;        callback(cellView);      &#125;    &#125;;    <span class="hljs-comment">// 绑定元素点击事件，坑注意：绑定 pointerclick 会有无法触发的 bug，退而监听 pointerup</span>    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'cell:pointerup link:pointerup'</span>, (cellView, evt, x, y) =&gt; bindFunc(cellView, evt, x, y));    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'blank:pointerup'</span>, (evt, x, y) =&gt; bindFunc(<span class="hljs-literal">null</span>, evt, x, y));  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@private</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>绑定连线相关属性，参考官方手册</span><span class="hljs-comment">   */</span>  bindLinkEvent() &#123;    <span class="hljs-comment">// 绑定连线的操作</span>    <span class="hljs-keyword">const</span> verticesTool = <span class="hljs-keyword">new</span> joint.linkTools.Vertices();    <span class="hljs-keyword">const</span> segmentsTool = <span class="hljs-keyword">new</span> joint.linkTools.Segments();    <span class="hljs-keyword">const</span> sourceArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceArrowhead();    <span class="hljs-keyword">const</span> targetArrowheadTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetArrowhead();    <span class="hljs-keyword">const</span> sourceAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.SourceAnchor();    <span class="hljs-keyword">const</span> targetAnchorTool = <span class="hljs-keyword">new</span> joint.linkTools.TargetAnchor();    <span class="hljs-keyword">const</span> boundaryTool = <span class="hljs-keyword">new</span> joint.linkTools.Boundary();    <span class="hljs-keyword">const</span> removeButton = <span class="hljs-keyword">new</span> joint.linkTools.Remove();    <span class="hljs-keyword">const</span> toolsView = <span class="hljs-keyword">new</span> joint.dia.ToolsView(&#123;      tools: [        verticesTool,        segmentsTool,        sourceArrowheadTool,        targetArrowheadTool,        sourceAnchorTool,        targetAnchorTool,        boundaryTool,        removeButton,      ],    &#125;);    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseenter'</span>, (linkView) =&gt; &#123;      linkView.addTools(toolsView);      linkView.showTools(toolsView);    &#125;);    <span class="hljs-keyword">this</span>.paper.on(<span class="hljs-string">'link:mouseleave'</span>, (linkView) =&gt; &#123;      <span class="hljs-comment">// 坑注意：3.1 版本不能用 addTools 和 removeTools 搭配，不然工具会 bug，显示不全</span>      linkView.hideTools();    &#125;);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加圆形</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>返回圆形元素的 ID</span><span class="hljs-comment">   */</span>  addCircle(x = <span class="hljs-number">10</span>, y = <span class="hljs-number">10</span>) &#123;    <span class="hljs-keyword">const</span> circle = <span class="hljs-keyword">new</span> joint.shapes.standard.Circle();    circle.resize(<span class="hljs-number">50</span>, <span class="hljs-number">50</span>);    circle.position(x, y);    circle.attr(<span class="hljs-string">'root/title'</span>, <span class="hljs-string">'测站号'</span>); <span class="hljs-comment">// dom 的 title 属性</span>    circle.attr(<span class="hljs-string">'label/text'</span>, <span class="hljs-string">''</span>); <span class="hljs-comment">// 文字</span>    circle.attr(<span class="hljs-string">'label/fontSize'</span>, <span class="hljs-string">'25'</span>); <span class="hljs-comment">// 文字大小</span>    circle.attr(<span class="hljs-string">'body/fill'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 背景颜色</span>    circle.attr(<span class="hljs-string">'body/stroke'</span>, <span class="hljs-string">'#f79204'</span>); <span class="hljs-comment">// 边框颜色</span>    circle.attr(<span class="hljs-string">'label/fill'</span>, <span class="hljs-string">'#fff'</span>);    <span class="hljs-keyword">this</span>.graph.addCell(circle);    <span class="hljs-keyword">return</span> circle.id;    <span class="hljs-comment">// joint.util.breakText('this is quite a long text', &#123; width: 50 &#125;) 自动根据宽度换行</span>  &#125;  <span class="hljs-comment">// 自定义元素失败，仅当参考</span>  addParamRect() &#123;    <span class="hljs-keyword">const</span> that = <span class="hljs-keyword">this</span>;    joint.shapes.html = &#123;&#125;;    joint.shapes.html.Element = joint.shapes.basic.Rect.extend(&#123;      defaults: joint.util.deepSupplement(        &#123;          type: <span class="hljs-string">'html.Element'</span>,          attrs: &#123;            rect: &#123; <span class="hljs-attr">stroke</span>: <span class="hljs-string">'none'</span>, <span class="hljs-string">'fill-opacity'</span>: <span class="hljs-number">0</span> &#125;,          &#125;,        &#125;,        joint.shapes.basic.Rect.prototype.defaults      ),    &#125;);    joint.shapes.html.ElementView = joint.dia.ElementView.extend(&#123;      template: [        <span class="hljs-string">'&lt;div class="html-element-rect"&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-header"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-body1"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-body2"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;div class="html-element-rect-body3"&gt;&lt;/div&gt;'</span>,        <span class="hljs-string">'&lt;/div&gt;'</span>,      ].join(<span class="hljs-string">''</span>),      initialize() &#123;        _.bindAll(<span class="hljs-keyword">this</span>, <span class="hljs-string">'updateBox'</span>);        joint.dia.ElementView.prototype.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);        <span class="hljs-keyword">this</span>.$box = $(_.template(<span class="hljs-keyword">this</span>.template)());        <span class="hljs-comment">// // This is an example of reacting on the input change and storing the input data in the cell model.</span>        <span class="hljs-comment">// this.$box.find('input').on(</span>        <span class="hljs-comment">//   'change',</span>        <span class="hljs-comment">//   _.bind(function (evt) &#123;</span>        <span class="hljs-comment">//     this.model.set('input', $(evt.target).val());</span>        <span class="hljs-comment">//   &#125;, this)</span>        <span class="hljs-comment">// );</span>        <span class="hljs-comment">// this.$box.find('select').on(</span>        <span class="hljs-comment">//   'change',</span>        <span class="hljs-comment">//   _.bind(function (evt) &#123;</span>        <span class="hljs-comment">//     this.model.set('select', $(evt.target).val());</span>        <span class="hljs-comment">//   &#125;, this)</span>        <span class="hljs-comment">// );</span>        <span class="hljs-comment">// this.$box.find('select').val(this.model.get('select'));</span>        <span class="hljs-comment">// this.$box.find('.delete').on('click', _.bind(this.model.remove, this.model));</span>        <span class="hljs-comment">// // Update the box position whenever the underlying model changes.</span>        <span class="hljs-keyword">this</span>.model.on(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">this</span>.updateBox, <span class="hljs-keyword">this</span>);        <span class="hljs-comment">// Remove the box when the model gets removed from the graph.</span>        <span class="hljs-keyword">this</span>.model.on(<span class="hljs-string">'remove'</span>, <span class="hljs-keyword">this</span>.removeBox, <span class="hljs-keyword">this</span>);        <span class="hljs-keyword">this</span>.updateBox();      &#125;,      render() &#123;        joint.dia.ElementView.prototype.render.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);        <span class="hljs-keyword">this</span>.paper.$el.prepend(<span class="hljs-keyword">this</span>.$box);        <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.paper, <span class="hljs-string">'scale'</span>, <span class="hljs-keyword">this</span>.updateBox);        <span class="hljs-keyword">this</span>.listenTo(<span class="hljs-keyword">this</span>.paper, <span class="hljs-string">'translate'</span>, <span class="hljs-keyword">this</span>.updateBox);        <span class="hljs-keyword">this</span>.updateBox();        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;      &#125;,      updateBox() &#123;        <span class="hljs-comment">// Set the position and dimension of the box so that it covers the JointJS element.</span>        <span class="hljs-keyword">const</span> bbox = <span class="hljs-keyword">this</span>.model.getBBox();        <span class="hljs-keyword">const</span> scale = that.paper.scale();        <span class="hljs-keyword">const</span> trans = that.paper.translate();        <span class="hljs-comment">// Example of updating the HTML with a data stored in the cell model.</span>        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-header'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'header'</span>));        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-body1'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'body1'</span>));        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-body2'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'body2'</span>));        <span class="hljs-keyword">this</span>.$box.find(<span class="hljs-string">'html-element-rect-body3'</span>).text(<span class="hljs-keyword">this</span>.model.get(<span class="hljs-string">'body3'</span>));        <span class="hljs-keyword">this</span>.$box.css(&#123;          <span class="hljs-comment">// transform: `scale($&#123;scale.sx&#125;,$&#123;scale.sy&#125;)`,</span>          transformOrigin: <span class="hljs-string">'0 0'</span>,          width: bbox.width * scale.sx,          height: bbox.height * scale.sy,          left: bbox.x * scale.sx + trans.tx,          top: bbox.y * scale.sy + trans.ty,        &#125;);      &#125;,      removeBox(evt) &#123;        <span class="hljs-keyword">this</span>.$box.remove();      &#125;,    &#125;);    <span class="hljs-keyword">const</span> el1 = <span class="hljs-keyword">new</span> joint.shapes.html.Element(&#123;      position: &#123; <span class="hljs-attr">x</span>: <span class="hljs-number">80</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">80</span> &#125;,      size: &#123; <span class="hljs-attr">width</span>: <span class="hljs-number">170</span>, <span class="hljs-attr">height</span>: <span class="hljs-number">100</span> &#125;,      header: <span class="hljs-string">'I am HTML'</span>,      body1: <span class="hljs-string">'1111'</span>,      body2: <span class="hljs-string">'2222'</span>,      body3: <span class="hljs-string">'3333'</span>,    &#125;);    <span class="hljs-keyword">this</span>.graph.addCell(el1);    <span class="hljs-keyword">return</span> el1.id;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加自定义的标题框，参数均为可选</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>width 宽度</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>height 高度</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>headerText 标题文字</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>bodyText1 红色预警文字</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> </span>bodyText2 普通文字</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;sting&#125;</span> </span>id 覆盖自身生成的 ID</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>返回元素ID</span><span class="hljs-comment">   */</span>  addHeaderRect(x = <span class="hljs-number">100</span>, y = <span class="hljs-number">10</span>, width = <span class="hljs-number">150</span>, height = <span class="hljs-number">100</span>, headerText = <span class="hljs-string">''</span>, bodyText1 = <span class="hljs-string">''</span>, bodyText2 = <span class="hljs-string">''</span>, id = <span class="hljs-string">''</span>) &#123;    <span class="hljs-keyword">const</span> headeredRectangle = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.customElement.HeaderRect();    headeredRectangle.resize(width, height);    headeredRectangle.position(x, y);    headeredRectangle.attr(<span class="hljs-string">'headerText/text'</span>, headerText);    headeredRectangle.attr(<span class="hljs-string">'bodyText1/text'</span>, bodyText1);    headeredRectangle.attr(<span class="hljs-string">'bodyText2/text'</span>, <span class="hljs-string">`\n<span class="hljs-subst">$&#123;bodyText2&#125;</span>`</span>); <span class="hljs-comment">// svg 控制换行非常麻烦，用 \n 能够解决换行的问题</span>    <span class="hljs-keyword">if</span> (id) &#123;      <span class="hljs-comment">// 回显画布时，覆盖自身生成的 ID</span>      headeredRectangle.prop([<span class="hljs-string">'id'</span>], id);    &#125;    <span class="hljs-keyword">this</span>.graph.addCell(headeredRectangle);    <span class="hljs-keyword">return</span> headeredRectangle.id;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加矩形</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 初始坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 初始坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;string&#125;</span> </span>返回矩形 ID</span><span class="hljs-comment">   */</span>  addRect(x = <span class="hljs-number">50</span>, y = <span class="hljs-number">10</span>) &#123;    <span class="hljs-keyword">const</span> rect = <span class="hljs-keyword">new</span> joint.shapes.standard.Rectangle();    rect.resize(<span class="hljs-number">90</span>, <span class="hljs-number">40</span>);    rect.position(x, y);    rect.attr(<span class="hljs-string">'root/title'</span>, <span class="hljs-string">'joint.shapes.standard.Rectangle'</span>);    rect.attr(<span class="hljs-string">'label/text'</span>, <span class="hljs-string">''</span>);    rect.attr(<span class="hljs-string">'label/fontSize'</span>, <span class="hljs-string">'18'</span>);    rect.attr(<span class="hljs-string">'body/stroke'</span>, <span class="hljs-string">'#6cbd16'</span>);    rect.attr(<span class="hljs-string">'body/fill'</span>, <span class="hljs-string">'#6cbd16'</span>);    rect.attr(<span class="hljs-string">'label/fill'</span>, <span class="hljs-string">'#fff'</span>);    <span class="hljs-keyword">this</span>.graph.addCell(rect);    <span class="hljs-keyword">return</span> rect.id;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>添加连接线</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>x 初始坐标</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;number&#125;</span> </span>y 初始坐标</span><span class="hljs-comment">   */</span>  addLink(x = <span class="hljs-number">50</span>, y = <span class="hljs-number">50</span>) &#123;    <span class="hljs-keyword">const</span> link = <span class="hljs-keyword">new</span> joint.shapes.standard.Link();    link.source(&#123; x, y &#125;); <span class="hljs-comment">// 起点，可以传元素字符串 ID</span>    link.target(&#123; <span class="hljs-attr">x</span>: x + <span class="hljs-number">80</span>, y &#125;); <span class="hljs-comment">// 终点</span>    link.labels([      &#123;        attrs: &#123;          text: &#123;            text: <span class="hljs-string">''</span>, <span class="hljs-comment">// 标签文字</span>          &#125;,        &#125;,      &#125;,    ]);    link.attr(<span class="hljs-string">'line/stroke'</span>, <span class="hljs-string">'#2f76ff'</span>); <span class="hljs-comment">// 线条颜色</span>    link.prop([<span class="hljs-string">'doubleLinkTools'</span>], <span class="hljs-string">'true'</span>); <span class="hljs-comment">// 显示双箭头</span>    link.prop([<span class="hljs-string">'labels'</span>, <span class="hljs-number">0</span>, <span class="hljs-string">'attrs'</span>, <span class="hljs-string">'rect'</span>, <span class="hljs-string">'fill'</span>], <span class="hljs-string">'rgba(0, 0, 0, 0)'</span>); <span class="hljs-comment">// 标签背景矩形颜色</span>    <span class="hljs-keyword">this</span>.graph.addCell(link);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>移除单个元素</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>cellView 元素对象，视图对象或者模型对象均可</span><span class="hljs-comment">   */</span>  removeItem(cellView) &#123;    <span class="hljs-keyword">if</span> (cellView.model &amp;&amp; <span class="hljs-keyword">typeof</span> cellView.model.remove === <span class="hljs-string">'function'</span>) &#123;      cellView.model.remove();    &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> cellView.remove === <span class="hljs-string">'function'</span>) &#123;      cellView.remove();    &#125;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>获取当前画布所有元素</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Array&#125;</span> </span>元素数组</span><span class="hljs-comment">   */</span>  getCells() &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCells();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>用元素 ID 获取元素视图对象</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;string&#125;</span> <span class="hljs-variable">id</span></span></span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> </span>元素视图对象</span><span class="hljs-comment">   */</span>  getCellByID(id) &#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.graph.getCell(id);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>获取画布当前的缩放比例和平移位置</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-type">&#123;scale, position&#125;</span></span></span><span class="hljs-comment">   */</span>  getPaperScaleAndPos() &#123;    <span class="hljs-keyword">const</span> scale = <span class="hljs-keyword">this</span>.paper.scale();    <span class="hljs-keyword">const</span> position = <span class="hljs-keyword">this</span>.paper.translate();    <span class="hljs-keyword">return</span> &#123; scale, position &#125;;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>清除当前画布</span><span class="hljs-comment">   */</span>  clearGraph() &#123;    <span class="hljs-keyword">this</span>.graph.clear();  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>销毁当前画布，并且销毁画布所有监听事件</span><span class="hljs-comment">   */</span>  destroy() &#123;    <span class="hljs-keyword">this</span>.clearGraph();    <span class="hljs-keyword">this</span>.paper.remove();    <span class="hljs-keyword">this</span>.element.removeEventListener(<span class="hljs-string">'mousemove'</span>, <span class="hljs-keyword">this</span>.dragFunc);  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>导出画布元素</span><span class="hljs-comment">   * <span class="hljs-doctag">@return <span class="hljs-type">&#123;Object&#125;</span> <span class="hljs-variable">JSON</span></span></span><span class="hljs-comment">   */</span>  exportGraph() &#123;    <span class="hljs-keyword">const</span> jsonData = <span class="hljs-keyword">this</span>.graph.toJSON();    <span class="hljs-keyword">return</span> jsonData;  &#125;  <span class="hljs-comment">/**</span><span class="hljs-comment">   * <span class="hljs-doctag">@public</span></span><span class="hljs-comment">   * <span class="hljs-doctag">@description </span>导入画布数据，JSON 对象，非 JSON 字符串</span><span class="hljs-comment">   * <span class="hljs-doctag">@param <span class="hljs-type">&#123;Object&#125;</span> </span>jsonData JSON</span><span class="hljs-comment">   * <span class="hljs-doctag">@example <span class="hljs-type">&#123;"cells": [&#123;...&#125;</span></span>, &#123;...&#125;]&#125;</span><span class="hljs-comment">   */</span>  importGraph(jsonData) &#123;    <span class="hljs-keyword">this</span>.graph.fromJSON(jsonData);  &#125;&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> JointJS;</code></pre>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>在 koa2 上使用 swagger 自动生成接口文档</title>
    <link href="/20200819/"/>
    <url>/20200819/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/83760346_p0.png" srcset="/img/loading.gif" alt=""></p><h1 id="在-koa2-上使用-swagger-自动生成接口文档"><a href="#在-koa2-上使用-swagger-自动生成接口文档" class="headerlink" title="在 koa2 上使用 swagger 自动生成接口文档"></a>在 koa2 上使用 swagger 自动生成接口文档</h1><!-- TOC --><ul><li><a href="#在-koa2-上使用-swagger-自动生成接口文档">在 koa2 上使用 swagger 自动生成接口文档</a><ul><li><a href="#11-配置步骤">1.1. 配置步骤</a><ul><li><a href="#111-安装">1.1.1. 安装</a></li><li><a href="#112-配置-swagger-jsdoc">1.1.2. 配置 swagger-jsdoc</a></li><li><a href="#113-配置-koa2--swagger-ui">1.1.3. 配置 koa2–swagger-ui</a></li></ul></li><li><a href="#12-文档使用">1.2. 文档使用</a></li></ul></li></ul><!-- /TOC --><hr><p>swagger 官网介绍 <a href="https://swagger.io/" target="_blank" rel="noopener">https://swagger.io/</a></p><p>在 koa2 中要想方便快捷使用 swagger，需要安装两个插件</p><ul><li><p>swagger-jsdoc：<a href="https://github.com/Surnet/swagger-jsdoc" target="_blank" rel="noopener">https://github.com/Surnet/swagger-jsdoc</a></p></li><li><p>koa2-swagger-ui：<a href="https://www.npmjs.com/package/koa2-swagger-ui" target="_blank" rel="noopener">https://www.npmjs.com/package/koa2-swagger-ui</a></p></li></ul><p>其实这两个插件并没有依赖关系，前者 swagger-jsdoc 的作用是通过手动添加的路由注释生成 json 文档，而后者 koa2-swagger-ui 则基于生成的 json 文档提供强大的交互阅读界面</p><h2 id="1-1-配置步骤"><a href="#1-1-配置步骤" class="headerlink" title="1.1. 配置步骤"></a>1.1. 配置步骤</h2><h3 id="1-1-1-安装"><a href="#1-1-1-安装" class="headerlink" title="1.1.1. 安装"></a>1.1.1. 安装</h3><blockquote><p>npm i -D swagger-jsdoc koa2-swagger-ui</p></blockquote><h3 id="1-1-2-配置-swagger-jsdoc"><a href="#1-1-2-配置-swagger-jsdoc" class="headerlink" title="1.1.2. 配置 swagger-jsdoc"></a>1.1.2. 配置 swagger-jsdoc</h3><ol><li>首先在项目根目录下新建 <code>swagger.conf.js</code>，示例</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> swaggerJSDoc = <span class="hljs-built_in">require</span>(<span class="hljs-string">"swagger-jsdoc"</span>);<span class="hljs-keyword">const</span> swaggerDefinition = &#123;  info: &#123;    <span class="hljs-comment">// 自定义文档信息</span>    title: <span class="hljs-string">"gallery"</span>,    version: <span class="hljs-string">"1.0.0"</span>,    description: <span class="hljs-string">"gallery 网站后台 koa api"</span>,  &#125;,  host: <span class="hljs-string">`localhost:3000`</span>, <span class="hljs-comment">// 指定项目地址，建议在环境参数中配置，然后用 process.env 读取</span>  basePath: <span class="hljs-string">"/"</span>,&#125;;<span class="hljs-keyword">const</span> options = &#123;  swaggerDefinition,  apis: [<span class="hljs-string">"./app/routes/*.js"</span>], <span class="hljs-comment">// 指定项目路由的相对路径，相对于 basePath</span>&#125;;<span class="hljs-keyword">const</span> swaggerSpec = swaggerJSDoc(options);<span class="hljs-built_in">module</span>.exports = swaggerSpec;</code></pre><ol><li>在上述配置文件中导出 swaggerSpec 后，新建一个路由 <code>docs.js</code>，返回该配置文件（其实就是指向了 swagger-jsdoc 生成的 json 文档），<strong>此路由返回的文档正是 koa2–swagger-ui 所需的 json 文档</strong></li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> Router = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa-router"</span>);<span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router();<span class="hljs-keyword">const</span> swaggerSpec = <span class="hljs-built_in">require</span>(<span class="hljs-string">"../../swagger.conf"</span>); <span class="hljs-comment">// 注意文件路径</span><span class="hljs-comment">// 注意 url 地址，可自定义，在 koa2--swagger-ui 配置中需要引用</span>router.get(<span class="hljs-string">"/swaggerDoc"</span>, <span class="hljs-keyword">async</span> (ctx) =&gt; &#123;  ctx.body = swaggerSpec;&#125;);<span class="hljs-built_in">module</span>.exports = router;</code></pre><h3 id="1-1-3-配置-koa2–swagger-ui"><a href="#1-1-3-配置-koa2–swagger-ui" class="headerlink" title="1.1.3. 配置 koa2–swagger-ui"></a>1.1.3. 配置 koa2–swagger-ui</h3><ol><li>在项目入口文件中配置 koa2–swagger-ui，示例</li></ol><pre><code class="hljs js"><span class="hljs-keyword">const</span> Koa = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa"</span>);<span class="hljs-keyword">const</span> app = <span class="hljs-keyword">new</span> Koa();<span class="hljs-keyword">const</span> swagger = <span class="hljs-built_in">require</span>(<span class="hljs-string">"koa2-swagger-ui"</span>);<span class="hljs-keyword">const</span> routing = <span class="hljs-built_in">require</span>(<span class="hljs-string">"./routes"</span>);<span class="hljs-comment">// 开启 swagger 静态服务</span>app.use(  swagger(&#123;    routePrefix: <span class="hljs-string">"/docs"</span>, <span class="hljs-comment">// 自定义 koa2-swagger-ui 生成的交互界面 url</span>    swaggerOptions: &#123;      <span class="hljs-comment">// 重要选项！url地址一定要指向为 swagger-jsdoc 配置的路由地址</span>      url: <span class="hljs-string">"http://localhost:3000/swaggerDoc"</span>,    &#125;,  &#125;));<span class="hljs-comment">// 路由绑定请自行实现</span>routing(app);app.listen(<span class="hljs-number">3000</span>, () =&gt; &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"App running at 3000 port"</span>);&#125;);</code></pre><h2 id="1-2-文档使用"><a href="#1-2-文档使用" class="headerlink" title="1.2. 文档使用"></a>1.2. 文档使用</h2><p>至此，swagger 的配置就已经全部完成，访问 <code>http://localhost:3000/docs</code> 即可查看 swagger-ui 提供的强大操作界面，接下来只要为各个路由加上注释即可，路由注释规范可参考官网示例 <a href="https://github.com/Surnet/swagger-jsdoc/blob/master/example/v2/routes.js" target="_blank" rel="noopener">https://github.com/Surnet/swagger-jsdoc/blob/master/example/v2/routes.js</a></p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记一次星轨拍摄</title>
    <link href="/20200816/"/>
    <url>/20200816/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/star.png" srcset="/img/loading.gif" alt=""></p><p>本来打算12号回老家拍英仙座流星雨，结果天公不作美，天气太差了，13号才回去，然而13号天气也不算太好</p><p>经过两三个小时和蚊子斗智斗勇，拍了300来张照片之后，发现几乎就没拍到流星，只有两三颗而且特别暗，太失望了。。最后只能拿一组照片做星轨了</p><p>不过因为老家后面火车还挺多的，多少也给照片添了一些亮点，真·亮点ww</p>]]></content>
    
    
    <categories>
      
      <category>随拍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>又是怀疑人生的一天</title>
    <link href="/20200621/"/>
    <url>/20200621/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/82374429_p0.jpg" srcset="/img/loading.gif" alt=""></p><p>——<em>人活着本来就没什么意义，又何必自己折磨自己</em></p><p>终于推完了 ATRI，故事很棒，结局也挺好，可是加上最近的烦心事，让我感觉更加怀疑人生了。</p><p>并不是我对未来有什么偏见，但是我真的觉得未来不值得我期待了，是因为还没摆脱心中那份孤独感吗。。我不明白。</p><p>明天老姐过生日了，也就是说，我的生日也快到了，不知道能不能在生日那天之前解脱，回家好好过生日呢。。希望如此吧。</p><p>为什么我会对他们抱着如此憎恨的心情呢，其实大家并不是多么坏的人，可能多少有点自私吧，但是谁又不是一样呢，我在别人眼中也不见得是多么正直的一个人吧。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最近遇到的一些坑</title>
    <link href="/20200607/"/>
    <url>/20200607/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/2020-06-07.jpg" srcset="/img/loading.gif" alt=""></p><h3 id="最近几天写-React、配置内网穿透遇到一些坑，记录一下。"><a href="#最近几天写-React、配置内网穿透遇到一些坑，记录一下。" class="headerlink" title="最近几天写 React、配置内网穿透遇到一些坑，记录一下。"></a>最近几天写 React、配置内网穿透遇到一些坑，记录一下。</h3><hr><h2 id="nginx-proxy-pass-路径解析"><a href="#nginx-proxy-pass-路径解析" class="headerlink" title="nginx proxy_pass 路径解析"></a>nginx proxy_pass 路径解析</h2><blockquote><p>在 <code>location</code> 块中，路径最后有无 <code>/</code> 号对解析结果影响很大，例如：</p></blockquote><pre><code class="hljs nginx"><span class="hljs-attribute">location</span> /api/ &#123;    <span class="hljs-attribute">proxy_pass</span> http://kanata.moe/;&#125;<span class="hljs-attribute">location</span> /api/ &#123;    <span class="hljs-attribute">proxy_pass</span> http://kanata.moe;&#125;</code></pre><p>这两种方式的解析结果是不一样的</p><ul><li>第一种方式，访问 <code>/api</code> 时，解析结果为 <a href="http://kanata.moe/" target="_blank" rel="noopener">http://kanata.moe/</a></li><li>第二种方式，访问 <code>/api</code> 时，解析结果为 <a href="http://kanata.moe/api" target="_blank" rel="noopener">http://kanata.moe/api</a></li></ul><hr><h2 id="koa2-组件-koa-body-与-koa-bodyParser-的冲突"><a href="#koa2-组件-koa-body-与-koa-bodyParser-的冲突" class="headerlink" title="koa2 组件 koa-body 与 koa-bodyParser 的冲突"></a>koa2 组件 koa-body 与 koa-bodyParser 的冲突</h2><p><code>koa-body</code> 组件能够处理文件上传和参数传递，而 <code>koa-bodyParser</code> 只能处理参数</p><blockquote><p>两个组件不能同时使用，否则 koa 可能不报错，但一直无响应</p></blockquote><h3 id="艰难的调试过程"><a href="#艰难的调试过程" class="headerlink" title="艰难的调试过程"></a>艰难的调试过程</h3><ol><li>前端 React 发出 ajax POST 上传文件请求，后端返回 504 响应超时</li><li>前端 Postman 模拟 POST 带参数请求，后端返回 200 处理成功</li><li>前端确认 React 中 ajax 请求代码无误</li><li>检查 nginx 代理设置与跨域设置，添加跨域选项（前后端并未发生跨域请求，删除跨域选项）</li><li>检查 koa2 路由设置正常，log 无报错，使用 console.log() 发现请求并未到达路由</li><li>检查 koa2 接收的访问参数、访问地址正常</li><li>用 console.log() 逐级排查 koa2 洋葱模型</li><li>定位到 core/init.js 中对 koa-body 和 koa-bodyParser 的引用</li><li>尝试删除对 koa-bodyParser 的引用，bug 修复成功</li></ol><hr><h2 id="MySQL-触发器的编写"><a href="#MySQL-触发器的编写" class="headerlink" title="MySQL 触发器的编写"></a>MySQL 触发器的编写</h2><p>MySQL 触发器是个非常方便的功能，能够快速实现数据表之间的数据关联，例：</p><pre><code class="hljs sql"><span class="hljs-keyword">USE</span> setu;<span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TRIGGER</span> <span class="hljs-keyword">IF</span> <span class="hljs-keyword">EXISTS</span> count_score;<span class="hljs-comment"># 将结束符号替换为 $$</span>DELIMITER $$<span class="hljs-keyword">CREATE</span> <span class="hljs-keyword">TRIGGER</span> count_score <span class="hljs-keyword">AFTER</span> <span class="hljs-keyword">INSERT</span> <span class="hljs-keyword">ON</span> scores <span class="hljs-keyword">FOR</span> <span class="hljs-keyword">EACH</span> <span class="hljs-keyword">ROW</span><span class="hljs-keyword">BEGIN</span>    <span class="hljs-comment"># 不能直接对 DECLARE 的变量赋值</span>    <span class="hljs-keyword">DECLARE</span> newScore <span class="hljs-built_in">INT</span>;    <span class="hljs-comment"># 使用 INTO 将 SELECT 结果赋值给变量</span>    <span class="hljs-keyword">SELECT</span> <span class="hljs-keyword">ROUND</span>(<span class="hljs-keyword">AVG</span>(score)) <span class="hljs-keyword">INTO</span> newScore <span class="hljs-keyword">FROM</span> scores <span class="hljs-keyword">WHERE</span> scores.picture_id = NEW.picture_id;    <span class="hljs-keyword">UPDATE</span> pictures <span class="hljs-keyword">SET</span> total_score = newScore <span class="hljs-keyword">WHERE</span> pictures.picture_id = NEW.picture_id;<span class="hljs-keyword">END</span>$$<span class="hljs-comment"># 将结束符号还原为 ;</span>DELIMITER ;</code></pre><p>其中，<code>NEW</code> 指即将插入或已经插入的行，<code>OLD</code> 指即将删除或已经删除的行</p><p>数学计算函数分别有：</p><p><code>AVG() 求平均值</code><br><code>ROUND() 四舍五入取整</code><br><code>CEILING() 向上取整</code><br><code>FLOOR() 向下取整</code></p><hr><h2 id="Let’s-encrypt-泛域名证书的申请"><a href="#Let’s-encrypt-泛域名证书的申请" class="headerlink" title="Let’s encrypt 泛域名证书的申请"></a>Let’s encrypt 泛域名证书的申请</h2><p>其实用 certbot 非常简单，首先安装 certbot，然后执行一条命令：</p><blockquote><p><code>sudo certbot certonly --preferred-challenges dns --manual -d kanata.moe -d *.kanata.moe</code></p></blockquote><ul><li><code>certonly</code> 仅生成证书</li><li><code>--preferred-challenges dns</code> 选择验证方式为 dns</li><li><code>--manual</code> 手动模式</li><li><code>-d</code> 泛域名可以用 * 号，但主域名也必须同时作为参数</li></ul><p>验证过程中，会要求在 dns 解析记录里添加一条 txt 解析<br>然后在 nginx 配置中引入证书路径即可，如：</p><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;    <span class="hljs-comment"># ...</span>    <span class="hljs-attribute">ssl_certificate</span> /etc/letsencrypt/live/kanata.moe/fullchain.pem;    <span class="hljs-attribute">ssl_certificate_key</span> /etc/letsencrypt/live/kanata.moe/privkey.pem;    <span class="hljs-comment"># ...</span>&#125;</code></pre><p><strong>注意：</strong> 修改与 SSL 相关的配置后，建议<strong>重启</strong> nginx 而不是使用 <code>nginx -s reload</code><br>可以使用 <code>sudo systemctl restart nginx</code> 等</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>心情逐渐平静</title>
    <link href="/20200322/"/>
    <url>/20200322/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/ETo-J4UU8AIpPj5.jpg" srcset="/img/loading.gif" alt=""></p><p>NAGA 作品，和白羽好像 w</p><p>也算是纠结了一段时间了，最近心情逐渐平静下来了，冷静考虑之后发现，生活其实也就这样，所谓人生也不过如此吧。所以现在也不会经常钻牛角尖了，平平淡淡也挺好的，追求太多只会被现实压垮而已。认真学学写代码，偶尔玩玩游戏，没事做做番，这样也挺好，还有什么好追求的呢。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>为什么会这么迷茫</title>
    <link href="/20200310/"/>
    <url>/20200310/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/ESWIAJfUYAI8ce-.png" srcset="/img/loading.gif" alt=""></p><p>五年挣扎终于看到了尽头，为什么反而更加迷茫了，简直就像失去了一切目标，弄丢了对这世界的好奇心。啊啊，原来我根本就不知道我自己究竟想要什么，只是一味地讨厌现在这种生活而已啊。</p><p>我所做的选择是一种自私吗，应该是吧，毕竟大家都说我这样做太蠢了，丝毫不顾及家人的感受，丝毫不考虑结婚生子以后的生活。可是我真的不打算结婚啊。</p><p>唯一让我担心的，就是这挥之不去的孤独感吧，可这又何妨，至少我还活着。我觉得我可能已经变得扭曲不堪了，而我却总是纵容着自己，回过头才发现，原来我依旧身处海南那片深深的绝望之中。</p><p>可是我也不想就这么结束啊，说不定明天会变得比今天好一点点呢，哪怕只是一点点。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>烦恼总是接连不断</title>
    <link href="/20200226/"/>
    <url>/20200226/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/ERmYjQIUEAIc5lW.png" srcset="/img/loading.gif" alt=""></p><p>今年二月还有 29 号</p><p>该为找工作发愁了。。之前觉得 PHP 的水平找工作应该不难，现在看来简直太天真了，根本就啥也不懂 ww</p><p>但是要不要转学前端呢，前端要补的东西还有很多，虽然 PHP 也要补但是基础比前端还是好一点。长远来看的话，PHP 竞争力肯定不如前端，但是 PHP 可以转后端架构，甚至转大数据。当然首先问题是能不能找到工作吧 ww</p><p>还是得先把网站项目做完，多学点东西再说吧</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>终于，只剩最后一点时间了</title>
    <link href="/20200118/"/>
    <url>/20200118/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_1194.jpg" srcset="/img/loading.gif" alt=""></p><p>私、何を…</p><p>当然，是从乐观的角度来说，再熬过半年就结束了，终于终于要结束了</p><p>长达 5 年的煎熬，虽然也不乏开心的事情，但也永远忘不了被逼入绝境的心情，现在终于看见曙光了，终于快走到终点了。</p><p>以后的事情谁也无法预料，生活这么艰难，谁又过得容易呢，而我也不过是想过得稍微开心一点点而已。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每次想写点东西的时候，都是心情不好的时候</title>
    <link href="/20191215/"/>
    <url>/20191215/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_1149.jpg" srcset="/img/loading.gif" alt=""></p><p>或者说每次心情不好的时候都想写点东西？</p><p>还是算了 w</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>住了一次医院，第一次觉得我开始活得像个普通人了</title>
    <link href="/20191122/"/>
    <url>/20191122/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/80965165_p0.jpg" srcset="/img/loading.gif" alt=""></p><p>虽然办了住院手续，不过也就是打针做检查的时候来医院，该上班还是要上班。第一次体会到了被重重现实压迫的无奈感。。明明往返医院已经很心累了，还要在单位疯狂受气。</p><p>这些肯定都是作为普通人需要面对的现实吧，以后工作了说不定还会有更离谱的事情，说不定离家远住院也没人照顾，动手术也只能自己一个人。但是这样也好，这样也是活着啊。</p><p>虽然一堆活没干完，但是休假批了，那就工作去他妈的，安排好住院啊考试啊之类的事情，然后好好休息吧~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>销毁了高中毕业以来的日记</title>
    <link href="/20191111/"/>
    <url>/20191111/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0925.jpg" srcset="/img/loading.gif" alt=""></p><p>8 年多了，日记虽然只写了 3 本，而且几乎都是些负面情绪，不过我还是决定全部扔进了碎纸机，一是保存不方便了，二是，该改改自己念旧的毛病了。</p><p>时间好漫长啊，真想现在就立马办完复员手续，一走了之。但是时间又过得好快啊，想想高中已经毕业 8 年多了，然而我还是任性不懂事。我也搞不懂我自己了 w</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>国庆节也过完啦</title>
    <link href="/20191006/"/>
    <url>/20191006/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/B15A9E56A90DD965BCD5BCBC9C6DF509.png" srcset="/img/loading.gif" alt=""></p><p>虽然国庆节也才三四天假，但是也算是扎扎实实玩了几天，玩过之后就忧郁了。。没有目标的感觉真难受，又迷茫又孤独。。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>最后的一年</title>
    <link href="/20190824/"/>
    <url>/20190824/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0521.jpg" srcset="/img/loading.gif" alt=""></p><p>恍恍惚惚，已经快到 9 月份了，4 年多了终于等来了应有的结果，明年终于可以摆脱组织的束缚，成为一个真正意义上的社会人了。</p><p>算上剩下的这一年，毕业正好 5 年，却也应验了当初说 5 年就可以回来的话，真是讽刺。5 年时间经历了太多，想到明年就要自己出去找工作了，反而有点不适应，也有点不安。</p><p>不过现在还没到放松的时候，最难的首先还是要熬过这一年吧，然后还要面临人生第一次找工作，不知道会碰壁多少次 ww。可是每次面临现在这些乱七八糟的工作内容，还是会觉得很烦人，又不得不好好完成，无奈也没办法，总之也就最后这一年了，再怎么折腾也就一年了，随它去吧。</p><p>好好睡一觉吧，明天也会是忙碌的一天，加班还有一年呢，趁着这一年，把想考的 JLPT、想学的画画、想做的 PHP，一个不落全都完成吧，毕竟，活着本来就没什么意义，还是不能太悲观对吧~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>哇啊啊啊啊</title>
    <link href="/20190807/"/>
    <url>/20190807/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0641.jpg" srcset="/img/loading.gif" alt=""></p><p>想说点开心的事情，但是想来想去好像也没什么开心的事情。。</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>追番list</title>
    <link href="/20190715/"/>
    <url>/20190715/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0597.jpg" srcset="/img/loading.gif" alt=""></p><p>平凡职业，cop craft，astra，女高日常，街角魔族，重来魔王，ct，jojo，fsn 第二部剧场(待续</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>原来家庭才是最大的困扰</title>
    <link href="/20190615/"/>
    <url>/20190615/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0492.jpg" srcset="/img/loading.gif" alt=""></p><p>老妈住院了，说要准备做结石手术，幸好老妹有空先回家了，还能照顾一下，我只能周一请假回去了。</p><p>突然觉得生活其实真的没有那么美好，现实总有压过梦想的时候，又不能随便抛弃这些牵绊，久而久之就会成为影响人生最大的困扰。而我呢？有时候太固执了，一心只想往前冲，可能甩掉了太多重要的东西了吧。不过这条路我还是会继续走下去，谁又知道明天世界会变成什么样子呢。</p><p>即便如此我也不想就此丢掉追逐美好的权利，加把劲~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>[预告]索尼A7+三阳35/2.8和A6000套机实用对比</title>
    <link href="/20190610/"/>
    <url>/20190610/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/EX_HPOnUYAYxlLE.jpg" srcset="/img/loading.gif" alt=""></p><p>终于，两台索法的入门级微单都回来了，其实很早就想写篇个人的使用感想了，等这段时间有空了就详细写一写吧。</p><p>其实个人喜欢 A7 多一点，尽管这两台入门辣鸡都属于优缺分明的机型，但是日常使用还是完全没问题的，敬请期待~</p>]]></content>
    
    
    <categories>
      
      <category>随拍</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>那么现在我该保持怎样的心态呢</title>
    <link href="/20190604/"/>
    <url>/20190604/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0455.jpg" srcset="/img/loading.gif" alt=""></p><p>夏天到啦~</p><p>天气越来越热，心情也跟着烦闷起来了，除了画画课和字幕组的活，代码已经很久没碰了，相机也基本处于吃灰状态，时间不够用（那还打什么游戏）。好想吃冰西瓜~</p><p>虽然按照予定计划，九月份左右就可以筹划罢工跑路了，不过唯一的不确定因素——跑路的代价，还没办法确定。那么在那之前，我该保持怎样的心态呢。或者说是否还有其他的解决方法？</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>记第一次服务器被暴力破解攻击</title>
    <link href="/20190429/"/>
    <url>/20190429/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0324.png" srcset="/img/loading.gif" alt=""></p><p>很久没维护过服务器了（大概一个月），今天 ssh 连上去看了一下，无意间发现 auth.log 的 fail 记录有点奇怪，重复查看之后发现服务器的 ssh 正在被暴力破解。。。来自好几个不同的 ip ，不过幸好只是单个 ip 的简单攻击，毫不犹豫直接加上了 fail2ban ，端口就懒得改了，ban 了 3 个 ip 之后清净了。。。有点吓人 ww，，以后还是得多注意服务器的安全问题了。。。</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>听说又有滚蛋的机会来了</title>
    <link href="/20190422/"/>
    <url>/20190422/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0370.png" srcset="/img/loading.gif" alt=""></p><p>本来年底抓住机会回来，就是为了等这个最终机会，现在似乎是脱离这个深坑最后的希望了。。明明都到了这时候，反而有点犹豫了。。虽然风险依然有，但是这是最后的机会了啊</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>每天都是上班下班....</title>
    <link href="/20190403/"/>
    <url>/20190403/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0309.jpg" srcset="/img/loading.gif" alt=""></p><p>已经有点感觉不到时间的流动了,,,上班下班一天过去了,,,上班下班一个星期过去了…..也没干啥活但是就是忙,,没办法,,暂时只能这样了吧,,唉</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>四畳半神話大系</title>
    <link href="/20190302/"/>
    <url>/20190302/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0221.png" srcset="/img/loading.gif" alt=""></p><p>首先，这部作品有点电波。。魔性的画风和前期重复的剧情和超高速的 CV 旁白有点劝退，,但是，最后的两集一下把所有的剧情全都连接起来，把所有想表达的感情全都连接起来，，瞬间把前期所有的疑惑都解开了，男主被困的时候，，仿佛被困的就是我自己，，就在那一秒之间，，我突然哭了，眼泪大颗大颗根本止不住。。（要不是我妈快下班回家，我能哭一整晚）</p><p>无尽的四畳半房间，无数的平行世界，就像我曾经身处的深渊，和无论怎么努力都逃不脱的命运。我也曾像男主一样，在那四畳半的房间，疯狂渴望着实现一般人根本不放在眼里的小小愿望， 疯狂渴望着，只要能逃出这命运的深渊我什么都愿意干。。。。</p><p>当男主从房间里逃出来的时候，我也回想起，两个月前，那种获得解放的愉悦感，绝非只言片语所能描绘，一花一草都会让我觉得，我还活着真是太好了。。。虽然那之后的我，也经常会迷茫不知所措，但是，，我所得到的，应该就是比一般人更能理解男主的心情吧~~</p><p>语无伦次了，，总之，，这是一部不容错过的好作品，感谢~~</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>VS code 插件</title>
    <link href="/20190225/"/>
    <url>/20190225/</url>
    
    <content type="html"><![CDATA[<p>auto close tag 自动关闭 html 标签</p><p>auto rename tag 自动更改 html 对应的标签</p><p>debugger for chrome 前端利用 chrome 断点调试</p><p>open in browser 右键浏览器打开文件</p><p>PHP debug 断点调试 PHP</p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>报了个画画的网络班</title>
    <link href="/20190222/"/>
    <url>/20190222/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/post/IMG_0238.jpg" srcset="/img/loading.gif" alt=""></p><p>ごと P 的画风非常治愈~~</p><p>也不知道该说是蓄谋已久,,还是一时头脑发热,,反正就是花了一笔不小的钱报了个班….虽然自己自学画了好几年了,,总是看不到进步也的确有点糟心…..(其实就是自己懒</p><p>不管怎么样,,画画肯定会成为之后生活的一部分了,,就算是有时候可能会很忙,,至少也有个缓解压力的方法吧</p><p>说个鸡掰哟,,妈蛋现在想做的事情太多了根本忙不过来了啊!!!!!….VPS 基本上已经成了个 SS 服务器了根本没时间更新网站…..但是不管怎么说,,不让自己闲下来终归是对的,,既然还有想去做的事情,,那就不遗余力的去完成,,,,以此来弥补那被狗吃掉的青春吧 2333</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新年的一点牢骚</title>
    <link href="/20190206/"/>
    <url>/20190206/</url>
    
    <content type="html"><![CDATA[<p>终于闲下心来可以写点东西了，经历了坎坷的本命年之后，现在的心情也是十分复杂。。</p><p>去年上半年可以说是我人生中最黑暗的一段时间了，压抑，暴躁，毫无理性，钻进死胡同出不来，精神接近崩溃，眼看着另一个朋友因为精神崩溃住进了特殊医院，庆幸我在掉下悬崖之前找回了自己，7 月份之后，我过得也还算一般。</p><p>然而就在我以为毫无希望可言的时候，12 月份我却从海南回来了，一点实感都没有，恍惚之间就这么过了一个多月。。在那之前，我日夜幻想着，当这一天到来的时候我会多么高兴多么开心。没想到世界线会以这样的方式收束，措手不及，来不及多想。。</p><p>我以为这就结束了，我一辈子的生活应该就这么被定格了，我也几乎快认命了。“待遇这么好，工作又稳定，我们都羡慕死你了”。这是我所有朋友的一致反应，包括我的家人，无一例外，仿佛这就是所有人一辈子最终的追求。</p><p>但是最近我开始反省，到底什么才是正确的，我所追求的到底是什么。。大学毕业已经有三年多了，我从泥沼之中痛苦挣扎，终于找到了自己的目标，现在的我却慢慢的失去了我曾经坚定不移的东西，曾经为之拼命的东西。。</p><p>这个岔路口可能对我而言没有选择的权利，但是这个岔路口直接决定我的命运，我很迷茫，但是如果真的能让我选择，我觉得我还是应该去拼一次，为了自己真正的梦想，为了自己定义的幸福，也为了不留下这个遗憾。</p><p>2019 年，希望我的幸运还没用完，希望我的血汗不会被白费，加油～</p><p><img src="/img/post/IMG_0139.jpg" srcset="/img/loading.gif" alt=""></p><p>你妈的为什么图倒了(</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>新年快乐！~~</title>
    <link href="/20190204/"/>
    <url>/20190204/</url>
    
    <content type="html"><![CDATA[<p>有时间再写点东西，，新年先快乐一下吧ww</p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>头痛</title>
    <link href="/20190125/"/>
    <url>/20190125/</url>
    
    <content type="html"><![CDATA[<p>简直比三年前那时候还要更迷茫，想着一些不着边际的东西。。</p><p><img src="/img/post/IMG_0005.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>碎碎念</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>关于这坑爹的 linux 版网易云。。</title>
    <link href="/20190123/"/>
    <url>/20190123/</url>
    
    <content type="html"><![CDATA[<p>安装完之后打不开，，结果搜到的玄学方法是双击加载的时候，，右上打开关机选项，然后再关闭，，，，然后网易云界面就出来了。。奇葩了。。。</p><p><img src="/img/post/81062782_p0.jpg" srcset="/img/loading.gif" alt=""></p>]]></content>
    
    
    <categories>
      
      <category>开发日志</category>
      
    </categories>
    
    
  </entry>
  
  
  
  
</search>
